Macro11_Parser

-Scan the entire line in mainline, pass as vector to parser object
-Pass compound token values as vector to parser object
-Everytime parser encounters a compound token it calls a screener function
which may change the token value and can provide further data (ex. opcode type)
at the same time.

input:
//from scanner

output:
//Addressing modes
aRegisterMode (R)
aRegisterDeferredMode (@R or (ER))
aAutoIncrementMode ((ER+))
aAutoIncrementDeferredMode (@(ER)+)
aAutoDecrementMode (-(ER))
aAutoDecrementDeferredMode (@-(ER))
aIndexMode (E(ER))
aIndexDeferredMode (@E(ER)
aImmediateMode (#E)
aAbsoluteMode (@#E)
aRelativeMode (E)
aRelativeDeferredMode (@E)

//assembled statments

parse:				// will exist in mainline (not as parser object)
  {[
	| pNewLine:
	| *:
	  @statement
  }];

statement:
  [
	| pLabel,pGlobalLabel:
	  @statement
	| pSymbol:
	  [ oChooseSymbol >> type
		| Opcode:			%part of the PST
		  @opcode
		| AssemblerDirective:		%part of the PST
		  @assemblerDirective
		| MacroCall:			%previously defined macro in MST
		  @macroCall
		| Symbol:			%direct assignment statement
		  [
			| pEquals:
		  	  @expression
			| *:
			  #eIllegalStatement
		  ]
	  ]
	| pPeriod:				%current location counter assignment
	  [
		| pEquals:
	  	  @expression
		| *:
		  #eIllegalStatement
	  ]
        | *:
	  #eIllegalStatement
  ];

opCode:
  [ opCode >> type
	| singleOperand:
	  @operand
	  >
	| doubleOperand:
	  @operand
	  [
		| pOperandFieldSeparator:
		  @operand
		| *:
		  #eMissingOperator
	  ]
	| branch:
	  @expression
	  >
	| jumpSubroutine
	  @scanJumpSubroutine		%operand is different depending on instruction
	  >
	| trapInterrupt:
	  @scanTrapInterrupt		%operand is different depending on instruction
	  >
	| conditionCode:
	  >				%opcode is determined based solely on mnemonic
	| miscellaneous:
	  @scanMiscellaneous		%operand is different depending on instruction
	  >
  ];

operand:
  [
	| pSymbol:
	  [ oChooseSymbol  >> type
		| Register:
		  .aRegisterMode
		| *:
		  @expression
		  [
			| pLeftParen:
			  @registerExpression
			  [
				| pRightParen:
				  .aIndexMode
				| *:
				  #eIllegalOperandSpecification
			  ]
			| *:
			  .aRelativeMode
		  ]
	  ]
	| pDeferredAddressingIndicator:
	  [
		| pSymbol:
	  	  [ oChooseSymbol  >> type
			| Register:
			  .aRegisterDeferredMode
			| *:
		 	  @expression
			  [
				| pLeftParen:
				  @registerExpression
				  [
					| pRightParen:
					  .aIndexDeferredMode
					| *:
					  #eIllegalOperandSpecification
				  ]
				| *:
				  .aRelativeDeferredMode
			  ]
		| pMinus:
		  [
			| pLeftParen:
			  @registerExpression
			  [
				| pRightParen:
				  .aAutoDecrementDeferredMode
				| *:
				  #eIllegalOperandSpecification
			  ]
			| *:
			  #eIllegalOperandSpecification
		  ]
		| pLeftParen:
		  @registerExpression
		  [
			| pRightParen:
			  [
				| pPlus:
				  .aAutoIncrementDeferredMode
				| *:
				  #eIllegalOperandSpecification
			  ]
			| *:
			  #eIllegalOperandSpecification
		  ]
		| pImmediateExpressionIndicator:
		  @expression
		  .aAbsoluteMode
	  ]
	| pLeftParen:
	  @registerExpression
	  [
		| pRightParen:
		  [
		  	| pPlus:
			  .aAutoIncrementMode
			| *:
			  .aRegisterDeferredMode
		  ]
		| *:
		  #eIllegalOperandSpecification
	  ]
	| pMinus:
	  [
		| pLeftParen:
		  @expression
		  [
			| pRightParen:
			  .aAutoDecrementMode
			| *:
			  #eIllegalOperandSpecification
		  ]
		| *:
		  #eIllegalOperandSpecification
	  ]
	| pImmediateExpressionIndicator:	%Must be Immediate Mode
	  @expression
	  .aImmediateMode
  ];


registerExpression:
  [
	| pSymbol:
	  [ oChooseSymbol  >> type
		| Register:
		  >
		| *:
		  @expression
		  [ oChooseExpression >> type
			| absolute:
			  [ oChooseExpressionValue >> value
				| 0-7:
				  >
				| *:
				  #eIllegalRegisterExpression
			  ]
			| *:
			  #eIllegalRegisterExpression
		  ]
	    ]
	| *:
	  #eIllegalRegisterExpression
  ];

expression:
  @term
  {[
	| pPlus,pMinus,pMultiply,pDivide,pAnd,pOr:
	  oPushExpressionOperator
	  @expression
	| *:
	  oEvaluateExpression
	  >
  ]};


term:
  {[
	| pPlus,pMinus,pUnary:
	  oPushTermOperator
	  @term
	| pLeftBracket:
	  @expression
	  [
		| pRightBracket:
		  oEvaluateTerm
		  >
		| *:
		  #eIllegalTerm
	  ]
	| pNumericLiteral:
	  oEvaluateTerm
	  >
	| pPeriod:
	  oEvaluateTerm
	  >
	| pSymbol:
	  [ oChooseSymbol >> type
		| symbol,opcode:
		  oEvaluateTerm
		  >
		| *:
		  #eIllegalTerm
		  >
	  ]
	| pSingleASCII:
	  [
		| pSymbol		%check if single ASCII character
		  oEvaluateTerm
		  >
		| *:
		  #eIllegalTerm
		  >
	  ]
	| pDoubleASCII:
	  [
		| pSymbol		%check if double ASCII character
		  oEvaluateTerm
		  >
		| *:
		  #eIllegalTerm
		  >
	  ]
  ]};


assemblerDirective:
  [

  ];

macroCall:
  [

  ];