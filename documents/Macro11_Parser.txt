Macro11_Parser

-Scan the entire line in mainline, pass as vector to parser object
-Pass compound token values as vector to parser object
-Everytime parser encounters a compound token it calls a screener function
which may change the token value and can provide further data (ex. opcode type)
at the same time.

input:
//from scanner

output:
//Addressing modes
aRegisterMode (R)
aRegisterDeferredMode (@R or (ER))
aAutoIncrementMode ((ER+))
aAutoIncrementDeferredMode (@(ER)+)
aAutoDecrementMode (-(ER))
aAutoDecrementDeferredMode (@-(ER))
aIndexMode (E(ER))
aIndexDeferredMode (@E(ER)
aImmediateMode (#E)
aAbsoluteMode (@#E)
aRelativeMode (E)
aRelativeDeferredMode (@E)

//assembled statments

parse:				// will exist in mainline (not as parser object)
  {[
	| pNewLine:
	| *:
	  @statement
  }];

statement:
  [
	| pLabel,pGlobalLabel:
	  @statement
	| pOperator:
	  [oChooseOperator >> type
		| pOpcode:
		  @opcode
		| pAssemblerDirective:
		  @assemblerDirective
		| pMacroCall:
		  @macroCall
	  ]
	| pSymbol,pGlobalSymbol:
	  @expression
        | *:
	  #eIllegalStatement
  ];

opCode:
  [ opCode >> type
	| singleOperand:
	  @addressingMode
	  >
	| doubleOperand:
	  @addressingMode
	  pOperandFieldSeparator
	  @expression
	  >
	| branch:
	  @expression
	  >
	| jumpSubroutine
	  @scanJumpSubroutine		%operand is different depending on instruction
	  >
	| trapInterrupt:
	  @scanTrapInterrupt		%operand is different depending on instruction
	  >
	| conditionCode:
	  >				%opcode is determined based solely on mnemonic
	| miscellaneous:
	  @scanMiscellaneous		%operand is different depending on instruction
	  >
  ];

addressingMode:
  [
	| pRegisterTerm:		%Register Mode
	  @registerTerm
	  .aRegisterMode
	| pSymbol:
	  [ oChooseSymbol  >> type
		| Register:
		  .aRegisterMode
		|
		  
	  ]
	| pDeferredAddressingIndicator:
	  [
		|

		|

	  ]
	| pLeftParen:

	| pMinus:

	| pImmediateExpressionIndicator:

  ];

assemblerDirective:
  [

  ];

macroCall:
  [

  ];

expression:
  [

  ];


term:
  [

  ];