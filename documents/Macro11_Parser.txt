Macro11_Parser

-Scan the entire line in mainline, pass as vector to parser object
-Pass compound token values as vector to parser object
-Everytime parser encounters a compound token it calls a screener function
which may change the token value and can provide further data (ex. opcode type)
at the same time.

input:
//from scanner

output:
//Addressing modes
aRegisterMode (R)
aRegisterDeferredMode (@R or (ER))
aAutoIncrementMode ((ER+))
aAutoIncrementDeferredMode (@(ER)+)
aAutoDecrementMode (-(ER))
aAutoDecrementDeferredMode (@-(ER))
aIndexMode (E(ER))
aIndexDeferredMode (@E(ER)
aImmediateMode (#E)
aAbsoluteMode (@#E)
aRelativeMode (E)
aRelativeDeferredMode (@E)

//assembled statments

parse:				// will exist in mainline (not as parser object)
  {[
	| pNewLine:
	| *:
	  @statement
  }];

statement:
  [
	| pLabel,pGlobalLabel:
	  @statement
	| pSymbol:
	  [ oChooseSymbol >> type
		| Opcode:			%part of the PST
		  @opcode
		| AssemblerDirective:		%part of the PST
		  @assemblerDirective
		| MacroCall:			%previously defined macro in MST
		  @macroCall
		| symbol:			%not previously defined
		  @expression
	  ]
        | *:
	  #eIllegalStatement
  ];

opCode:
  [ opCode >> type
	| singleOperand:
	  @addressingMode
	  >
	| doubleOperand:
	  @addressingMode
	  [
		| pOperandFieldSeparator:
		  @addressingMode
		| *:
		  #eMissingOperator
	  ]
	| branch:
	  @expression
	  >
	| jumpSubroutine
	  @scanJumpSubroutine		%operand is different depending on instruction
	  >
	| trapInterrupt:
	  @scanTrapInterrupt		%operand is different depending on instruction
	  >
	| conditionCode:
	  >				%opcode is determined based solely on mnemonic
	| miscellaneous:
	  @scanMiscellaneous		%operand is different depending on instruction
	  >
  ];

addressingMode:
  [
	| pRegisterTerm:			%Must be register Mode
	  @registerTerm
	  .aRegisterMode
	| pSymbol:
	  [ oChooseSymbol  >> type
		| Register:
		  .aRegisterMode
		| *:
		  @expression
		  [
			| pLeftParen:
			  @registerExpression
			  [
				| pRightParen:
				  .aIndexMode
				| *:
				  #eIllegalOperatorSpecification
			  ]
			| *:
			  .aRelativeMode
		  ]
	  ]
	| pDeferredAddressingIndicator:
	  [
		| pSymbol:
	  	  [ oChooseSymbol  >> type
			| Register:
			  .aRegisterDeferredMode
			| *:
		 	  @expression
			  [
				| pLeftParen:
				  @registerExpression
				  [
					| pRightParen:
					  .aIndexDeferredMode
					| *:
					  #eIllegalOperatorSpecification
				  ]
				| *:
				  .aRelativeDeferredMode
			  ]
		| pMinus:
		| pLeftParen:
		| pImmediateExpressionIndicator:
	  ]
	| pLeftParen:
	  @registerExpression
	  [
		| pRightParen:
		  [
		  	| pPlus:
			  .aAutoIncrementMode
			| *:
			  .aRegisterDeferredMode
		  ]
		| *:
		  #eIllegalOperatorSpecification
	  ]
	| pMinus:
	  [
		| pLeftParen:
		  @expression
		  [
			| pRightParen:
			  .aAutoDecrementMode
			| *:
			  #eIllegalOperatorSpecification
		  ]
		| *:
		  #eIllegalOperatorSpecification
	  ]
	| pImmediateExpressionIndicator:	%Must be Immediate Mode
	  @expression
	  .aImmediateMode
  ];

assemblerDirective:
  [

  ];

macroCall:
  [

  ];

registerTerm:
  [

  ];

registerExpression:
  [

  ];

expression:
  [

  ];


term:
  [

  ];